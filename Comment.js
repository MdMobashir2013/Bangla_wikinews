//By [[User:Asked42[[
//In development
// <nowiki>

if (typeof window.commentSectionConfig === 'undefined') {
    window.commentSectionConfig = {
            addCommentHeader: 'মন্তব্য যোগ করুন',
            commentSectionTitle: 'মন্তব্য বিভাগ',
            recentCommentsHeader: 'সাম্প্রতিক মন্তব্য',
            submitButtonLabel: 'মন্তব্য যোগ করুন',
            submittingButtonLabel: 'জমা হচ্ছে...',
            viewAllButtonLabel: 'সব মন্তব্য দেখুন',
            clearButtonLabel: 'বাতিল',
            joinDiscussionButtonLabel: 'মন্তব্যটি দেখুন',
            commentPlaceholder: 'আপনার মন্তব্য এখানে লিখুন...',
            noCommentsMessage: 'এখনও কোনো মন্তব্য নেই। প্রথম ব্যক্তি হিসেবে মন্তব্য করুন!',
            emptyCommentError: 'জমা দেওয়ার আগে একটি মন্তব্য লিখুন।',
            successMessage: 'মন্তব্য সফলভাবে যোগ হয়েছে!',
            errorPrefix: 'মন্তব্য যোগ করতে ত্রুটি: ',
            autoSignMessage: 'মন্তব্যে স্বাক্ষর করার প্রয়োজন নেই। এটি স্বয়ংক্রিয়ভাবে স্বাক্ষরিত হবে।',
            commentTemplate: '{{Wn/bn/মন্তব্য}}',
            editSummary: 'নতুন মন্তব্য যোগ করা হয়েছে',
            commentIconLabel: 'একটি মন্তব্য লিখুন!',
            writeCommentButtonLabel: 'একটি মন্তব্য লিখুন!',
            
            guidelinesMessage: "অনুগ্রহ করে নতুন মন্তব্য যোগ করার আগে মন্তব্য বিভাগের নির্দেশিকাগুলি দেখে নিন।",
			guidelinesCloseLabel: "বন্ধ করুন",
			guidelinesLinkText: "নির্দেশিকা দেখুন।",
			guidelinesUrl: "https://w.wiki/DqcF", 
            
            // comment section settings 
            settingsIconTitle: 'মন্তব্য বিভাগের সেটিংস',
			settingsDialogTitle: 'মন্তব্য বিভাগের সেটিংস',
			settingsSaveLabel: 'পরিবর্তন সংরক্ষণ করুন',
			settingsCloseLabel: 'বন্ধ করুন',
			settingsCollapseLabel: 'সর্বদা সাম্প্রতিক মন্তব্য সংকুচিত রাখুন',
			settingsCollapseDescription: 'সাম্প্রতিক মন্তব্যের বিভাগকে সর্বদা ডিফল্টভাবে সংকুচিত রাখা হবে',
			settingsNoRedirectLabel: 'মন্তব্য করার পরে পুনঃনির্দেশনা নয়',
			settingsNoRedirectDescription: 'নতুন মন্তব্য যোগ করার পরে আলাপ পাতায় পুনঃনির্দেশ করা হবে না, নিবন্ধের পৃষ্ঠায় থাকবেন',
			settingsHideCommentsLabel: 'সাম্প্রতিক মন্তব্য লুকান',
			settingsHideCommentsDescription: 'সাম্প্রতিক মন্তব্য বিভাগ সম্পূর্ণরূপে প্রদর্শিত করানো হবে না',
			customAvatarButtonLabel: 'মন্তব্য আইকন টেমপ্লেট',
			customAvatarInstruction: 'মন্তব্যের জন্য আপনার পছন্দমতো আইকন বাছাই করুন:',
			settingsFooterDescription: 'আপনার পরিবর্তনগুলি এই ব্রাউজারে সংরক্ষিত থাকবে এবং অন্যান্য ডিভাইস বা ব্রাউজারে প্রযোজ্য হবে না। সংরক্ষণের পর পৃষ্ঠাটি পুনরায় লোড করুন।',
			
			// Like oparetions related
			likeButtonTitle: "এই মন্তব্যটি পছন্দ করুন",
		    unlikeButtonTitle: "আপনার পছন্দ সরিয়ে নিন",
		    likeSuccessMessage: "আপনি সফলভাবে মন্তব্যটি পছন্দ করেছেন!",
		    unlikeSuccessMessage: "আপনি সফলভাবে পছন্দ সরিয়ে নিয়েছেন!",
		    likeErrorMessage: "পছন্দ যোগ করতে ত্রুটি হয়েছে: ",
		    likeUpdateMessage: "পছন্দ আপডেট করা হচ্ছে...",
		    likeCount: "পছন্দ: %s",
		    
		    pageIndicatorLabel: 'পৃষ্ঠা %page% / %total%',
			previousButtonLabel: 'পূর্ববর্তী',
			nextButtonLabel: 'পরবর্তী' ,
			
			commentReactionTemplate: 'Wn/bn/Comment-reaction',
			customAvatarTemplate: 'Template:Wn/bn/মন্তব্যের_বিভাগ_আইকন',
		    icons: {
			    settings: 'https://upload.wikimedia.org/wikipedia/commons/d/dc/Settings-icon-symbol-vector.png',
			    comments: 'https://upload.wikimedia.org/wikipedia/commons/c/c4/Bootstrap_chat-right-text-fill.svg',
			    addComment: 'https://upload.wikimedia.org/wikipedia/commons/b/bf/OOjs_UI_icon_speechBubbleAdd-ltr-progressive.svg',
			    reply: 'https://upload.wikimedia.org/wikipedia/commons/2/22/Bootstrap_chat.svg',
			    like: 'https://upload.wikimedia.org/wikipedia/commons/8/8d/Feather-core-thumbs-up.svg',
			    likeActive: 'https://upload.wikimedia.org/wikipedia/commons/2/21/Ic_thumb_up_48px.svg',
			    avatarPre: 'https://upload.wikimedia.org/wikipedia/commons/9/98/OOjs_UI_icon_userAvatar.svg',
			    upArrow: 'https://upload.wikimedia.org/wikipedia/commons/9/9e/Collapse_Arrow_%2861412%29_-_The_Noun_Project.svg',
			    downArrow: 'https://upload.wikimedia.org/wikipedia/commons/d/d1/Expand_arrow_%2861408%29_-_The_Noun_Project.svg'
			}

    };
}

mw.loader.using(['@wikimedia/codex', 'mediawiki.api', 'mediawiki.jqueryMsg']).then(function(require) {
    const Vue = require('vue');
    const Codex = require('@wikimedia/codex');

    // Initialize global namespace and API instance
    const wikiNewsComments = window.wikiNewsComments || {};
    window.wikiNewsComments = wikiNewsComments;
    wikiNewsComments.api = wikiNewsComments.api || new mw.Api();

    // Constants and Caches
    const STORAGE_KEY = 'wikiNewsCommentsSettings';
    const DATE_FORMATS = {
        BENGALI: {
            TIMESTAMP: /([০-৯]+:[০-৯]+),\s*([০-৯]+\s+[\u0980-\u09FF]+\s+[০-৯]+)\s*(?:([\u0980-\u09FF]+))?/,
            DATE: /([০-৯]+)\s+([\u0980-\u09FF]+)\s+([০-৯]+)/
        },
        ENGLISH: {
            TIMESTAMP: /(\d{1,2}:\d{2}),\s*(\d{1,2}\s+\w+\s+\d{4})\s*(?:\(UTC\))?/,
            DATE: /(\d{1,2})\s+(\w+)\s+(\d{4})/
        }
    };

    const bengaliDigitsMap = ['০', '১', '২', '৩', '৪', '৫', '৬', '৭', '৮', '৯'];
    const digitRegex = /\d/g;
    
    const bengaliMonths = {
        'January': 'জানুয়ারি',
        'February': 'ফেব্রুয়ারি',
        'March': 'মার্চ',
        'April': 'এপ্রিল',
        'May': 'মে',
        'June': 'জুন',
        'July': 'জুলাই',
        'August': 'আগস্ট',
        'September': 'সেপ্টেম্বর',
        'October': 'অক্টোবর',
        'November': 'নভেম্বর',
        'December': 'ডিসেম্বর'
    };

    const parsedCache = new Map();
    const sectionCache = new Map();
    const avatarApiCache = new Map();

    // Utility Functions
    const getStoredSettings = () => {
        try {
            const data = JSON.parse(mw.storage.get(STORAGE_KEY));
            if (data && typeof data === 'object') {
                return Object.freeze({
                    alwaysCollapsed: !!data.alwaysCollapsed,
                    noRedirect: !!data.noRedirect,
                    hideRecentComments: !!data.hideRecentComments
                });
            }
        } catch (e) {
            console.warn("Error reading settings, resetting to default.");
        }
        return Object.freeze({
            alwaysCollapsed: true,
            noRedirect: false,
            hideRecentComments: false
        });
    };

    const saveSettings = (settings) => {
        mw.storage.set(STORAGE_KEY, JSON.stringify(settings));
    };

    const toBengaliDigits = (number) => {
        return number.toString().replace(digitRegex, d => bengaliDigitsMap[d]);
    };

    const translateMonthToBengali = (month) => {
        return bengaliMonths[month] || month;
    };

    const isBengaliText = (text) => {
        return /[\u0980-\u09FF]/.test(text);
    };

    const extractDateFromText = (text) => {
        const bengaliTimestampMatch = text.match(DATE_FORMATS.BENGALI.TIMESTAMP);
        if (bengaliTimestampMatch) return bengaliTimestampMatch[2];

        const englishTimestampMatch = text.match(DATE_FORMATS.ENGLISH.TIMESTAMP);
        if (englishTimestampMatch) return translateDateToBengali(englishTimestampMatch[2]);

        const bengaliDateMatch = text.match(DATE_FORMATS.BENGALI.DATE);
        if (bengaliDateMatch) return bengaliDateMatch[0];

        const englishDateMatch = text.match(DATE_FORMATS.ENGLISH.DATE);
        if (englishDateMatch) return translateDateToBengali(englishDateMatch[0]);

        return '';
    };

    const translateDateToBengali = (dateStr) => {
        if (!dateStr) return '';
        const match = dateStr.match(DATE_FORMATS.ENGLISH.DATE);
        if (!match) return dateStr;
        const [_, day, month, year] = match;
        return `${toBengaliDigits(day)} ${translateMonthToBengali(month)} ${toBengaliDigits(year)}`;
    };

    const cleanTimestamp = (text) => {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = text;
        const sign = tempDiv.querySelector('#user-sign');
        if (sign) sign.remove();
        return tempDiv.innerHTML.trim();
    };

    // Comment Parsing Functions
    const parseCommentHeader = (headerText) => {
        const match = headerText.match(/(.*?) এর দ্বারা মন্তব্য(?:\s+\(([\u0980-\u09FF]+)\))?$/);
        if (!match) return { username: headerText, counter: null };
        return { username: match[1], counter: match[2] || null };
    };

    const getNextCommentCounter = (username, content) => {
        const regex = new RegExp(`=== ${username} এর দ্বারা মন্তব্য(?:\\s+\\(([\\u0980-\\u09FF]+)\\))? ===`, 'g');
        const matches = [...content.matchAll(regex)];
        if (matches.length === 0) return '';

        const bengaliDigitsToValues = {
            '১': 1, '২': 2, '৩': 3, '৪': 4, '৫': 5, '৬': 6, '৭': 7, '৮': 8, '৯': 9, '০': 0
        };

        const bengaliToNumber = (bengaliNumeral) => {
            let value = 0;
            for (let i = 0; i < bengaliNumeral.length; i++) {
                if (bengaliDigitsToValues[bengaliNumeral[i]] !== undefined) {
                    value = value * 10 + bengaliDigitsToValues[bengaliNumeral[i]];
                }
            }
            return value || 1;
        };

        let maxCounter = 1;
        for (const match of matches) {
            if (match[1]) {
                const numericValue = bengaliToNumber(match[1]);
                if (numericValue > maxCounter) maxCounter = numericValue;
            }
        }

        const nextCounter = maxCounter + 1;
        return nextCounter > 1 ? ` (${toBengaliDigits(nextCounter)})` : '';
    };

    const extractReactionData = (text) => {
        const templateName = window.commentSectionConfig.commentReactionTemplate;
        const reactionMatch = text.match(new RegExp(`\\{\\{${templateName}\\|like=(\\d+)\\|reactors=([^}]*)\\}\\}`));
        if (!reactionMatch) {
            return { likeCount: 0, reactors: [], hasReactionTemplate: false, templateText: '' };
        }

        const reactors = reactionMatch[2].split(',').map(name => name.trim()).filter(Boolean);
        return {
            likeCount: reactors.length,
            reactors,
            hasReactionTemplate: true,
            templateText: reactionMatch[0]
        };
    };

    const createReactionTemplate = (likeCount, reactors) => {
        const validReactors = reactors.filter(Boolean);
        const templateName = window.commentSectionConfig.commentReactionTemplate;
        return `{{${templateName}|like=${validReactors.length}|reactors=${validReactors.join(', ')}}}`;
    };

    const cleanupCommentText = (text) => {
        return text.replace(/\{\{Wn\/bn\/Comment-reaction\|like=\d+\|reactors=[^}]*\}\}\n?/g, '')
                  .replace(/\[\[(?:File|চিত্র|Image):[^\]]+\]\]/gi, '')
                  .trim();
    };

	const batchGetFileUrls = async (filenames) => {
	    wikiNewsComments.fileUrlCache = wikiNewsComments.fileUrlCache || new Map();
	    const resultMap = new Map();
	
	    // Filter out filenames already in cache
	    const uncachedFilenames = filenames.filter(filename => !wikiNewsComments.fileUrlCache.has(filename));
	    if (uncachedFilenames.length === 0) {
	        return new Map(filenames.map(filename => [filename, wikiNewsComments.fileUrlCache.get(filename)]));
	    }
	
	    try {
	        // Batch API call for uncached filenames
	        const response = await wikiNewsComments.api.get({
	            action: 'query',
	            titles: uncachedFilenames.map(filename => `File:${filename}`).join('|'),
	            prop: 'imageinfo',
	            iiprop: 'url',
	            format: 'json',
	            formatversion: '2'
	        });
	
	        const pages = response.query.pages;
	        for (const page of Object.values(pages)) {
	            const filename = page.title.replace(/^File:/, '');
	            if (page.imageinfo && page.imageinfo[0]) {
	                const url = page.imageinfo[0].url;
	                wikiNewsComments.fileUrlCache.set(filename, url);
	                resultMap.set(filename, url);
	            } else {
	                wikiNewsComments.fileUrlCache.set(filename, null);
	                resultMap.set(filename, null);
	            }
	        }
	
	        for (const filename of filenames) {
	            if (!resultMap.has(filename)) {
	                resultMap.set(filename, wikiNewsComments.fileUrlCache.get(filename));
	            }
	        }
	
	        return resultMap;
	    } catch (error) {
	        console.error('Error batch fetching file URLs:', error);
	        for (const filename of uncachedFilenames) {
	            wikiNewsComments.fileUrlCache.set(filename, null);
	            resultMap.set(filename, null);
	        }
	        return resultMap;
	    }
	};
	
	const fetchCustomAvatars = async () => {
	    if (wikiNewsComments.customAvatars) {
	        return wikiNewsComments.customAvatars;
	    }
	
	    const cacheKey = 'fetchCustomAvatars';
	    if (avatarApiCache.has(cacheKey)) {
	        return avatarApiCache.get(cacheKey);
	    }
	
	    const promise = (async () => {
	        try {
	            const response = await wikiNewsComments.api.get({
	                action: 'query',
	                titles: window.commentSectionConfig.customAvatarTemplate,
	                prop: 'revisions',
	                rvprop: 'content',
	                rvslots: 'main',
	                formatversion: '2'
	            });
	
	            if (!response.query.pages[0] || response.query.pages[0].missing) {
	                wikiNewsComments.customAvatars = new Map();
	                return wikiNewsComments.customAvatars;
	            }
	
	            const content = response.query.pages[0].revisions[0].slots.main.content;
	            const avatarMap = new Map();
	            
	            // Look for content between <!-- start --> and <!-- end -->
	            const sectionRegex = /<!-- start -->([\s\S]*?)<!-- end -->/;
	            const sectionMatch = content.match(sectionRegex);
	            
	            if (!sectionMatch) {
	                console.warn('No content found between <!-- start --> and <!-- end --> markers');
	                wikiNewsComments.customAvatars = new Map();
	                return wikiNewsComments.customAvatars;
	            }
	
	            const avatarContent = sectionMatch[1];
	            const mappingRegex = /^\*\s*([^=]+?)\s*=\s*File:([^|\n]+)/gm;
	            let match;
	
	            while ((match = mappingRegex.exec(avatarContent)) !== null) {
	                const username = match[1].trim();
	                const filename = match[2].trim();
	                avatarMap.set(username, filename);
	            }
	
	            if (avatarMap.size === 0) {
	                console.warn('No valid avatar mappings found between <!-- start --> and <!-- end -->');
	            }
	
	            wikiNewsComments.customAvatars = avatarMap;
	            return avatarMap;
	        } catch (error) {
	            console.error('Error fetching custom avatars:', error);
	            wikiNewsComments.customAvatars = new Map();
	            return new Map();
	        }
	    })();
	
	    avatarApiCache.set(cacheKey, promise);
	    return promise;
	};
	
	const getAvatar = async (username, commentId) => {
	    const customAvatars = await fetchCustomAvatars();
	
	    if (username && customAvatars.has(username)) {
	        const filename = customAvatars.get(username);
	        const fileUrl = await getFileUrl(filename);
	        if (fileUrl) {
	            return fileUrl;
	        }
	    }
	    
	    return getRandomAvatar(commentId);
	};
	
	const getFileUrl = async (filename) => {
	    wikiNewsComments.fileUrlCache = wikiNewsComments.fileUrlCache || new Map();
	    if (wikiNewsComments.fileUrlCache.has(filename)) {
	        return wikiNewsComments.fileUrlCache.get(filename);
	    }
	
	    const fileUrls = await batchGetFileUrls([filename]);
	    return fileUrls.get(filename);
	};
	
	const getRandomAvatar = (commentId) => {
	    const avatars = [
	        "https://upload.wikimedia.org/wikipedia/commons/e/ec/Circle-icons-pencil_2.svg",
	        "https://upload.wikimedia.org/wikipedia/commons/7/77/Circle-icons-bolt.svg", 
	        "https://upload.wikimedia.org/wikipedia/commons/b/b0/Circle-icons-brightness-green.svg",
	        "https://upload.wikimedia.org/wikipedia/commons/4/4a/Circle-icons-flame.svg",
	        "https://upload.wikimedia.org/wikipedia/commons/a/a0/Circle-icons-speaker.svg",
	        "https://upload.wikimedia.org/wikipedia/commons/b/bf/Circle-icons-weather.svg"
	    ];
	    
	  
	    const id = typeof commentId === 'string' ? parseInt(commentId.replace(/\D/g, ''), 10) : commentId;
	    const index = id % avatars.length;
	    return avatars[index];
	};

    const countReplies = (text) => {
        return (text.match(/^:+[^:]/gm) || []).length;
    };

    const getMainComment = (text) => {
        return text.split('\n').filter(line => !line.trim().startsWith(':')).join('\n');
    };

    // Debounce utility for throttling expensive operations
    const debounce = (func, wait) => {
        let timeout;
        return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => func(...args), wait);
        };
    };

    // DOM Initialization
    $(document).ready(function() {
    	if (mw.config.get('wgAction') === 'edit' || mw.config.get('wgAction') === 'visualeditor') {
	        return;
	    }
        if (mw.config.get('wgNamespaceNumber') !== 0) return;

        const commentSection = document.getElementById('wikidialog-comment-section-v2');
        const iconContainer = document.getElementById('wikidialog-comment-icon');

        if (commentSection && iconContainer) {
            const icon = document.createElement('img');
            icon.src = window.commentSectionConfig.icons?.comments;
            icon.style.cssText = 'width:20px;height:20px;cursor:pointer;';
            icon.className = 'skin-invert comment-icon';
            icon.title = commentSectionConfig.commentIconLabel;

            const style = document.createElement('style');
            style.textContent = `
                .comment-icon:hover { transform: scale(1.1); }
                .comment-icon { transition: transform 0.3s ease; }
            `;
            document.head.appendChild(style);

            icon.addEventListener('click', () => {
                const commentSection = document.querySelector('.wikinews-comments-container h2.cdx-heading');
                if (commentSection) {
                    commentSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });

            iconContainer.appendChild(icon);
        }

        const existingCommentSection = document.getElementById('wikidialog-comment-section-v2');
        if (!existingCommentSection) return;

        const contentBody = document.getElementById('mw-content-text');
        if (!contentBody) return;

        existingCommentSection.remove();
        const wrapper = document.createElement('div');
        wrapper.className = 'comment-section-wrapper';
        wrapper.style.marginTop = '2em';
        wrapper.appendChild(existingCommentSection);
        contentBody.appendChild(wrapper);

        // ===== VUE APP CREATION =====
        Vue.createMwApp({
            data: function() {
                return {
                    commentText: '',
		        isSubmitting: false,
		        pageName: mw.config.get('wgPageName'),
		        talkPageTitle: mw.Title.newFromText(mw.config.get('wgPageName')).getTalkPage().getPrefixedText(),
		        recentComments: [],
		        isLoadingComments: false,
		        showRecentComments: !getStoredSettings().alwaysCollapsed,
		        commentSectionConfig: window.commentSectionConfig,
		        settingsOpen: false,
		        settings: getStoredSettings(),
		        showGuidelinesNotice: false,
		        tempSettings: {},
		        allComments: [],     
		        commentBoxExpanded: false,
		        defaultCollapsedRows: 1,
		        commentsPerPage: 3,
		        currentPage: 0,
		        totalComments: 0,
		        loadingMoreComments: false,
		        pageContent: '',
		        commentMatches: [],
		        commentsInitialized: false,
		        isInitialLoading: false,
		        avatarCache: new Map(),
		        loadingStatus: 'pending',
		        showCommentBox: false,
		        commentBoxInitialized: false,
		        recentCommentsLoaded: false
                };
            },
            template: `
            <div class="wikinews-comments-container">
			    <h2 class="cdx-heading">{{ commentSectionConfig.addCommentHeader }}</h2>
			    <img v-if="isLoggedIn" :src="commentSectionConfig.icons?.settings" class="settings-icon skin-invert" :title="commentSectionConfig.settingsIconTitle" @click="openSettings" />
			
			    <cdx-dialog v-model:open="settingsOpen" :title="commentSectionConfig.settingsDialogTitle" :use-close-button="true" :primary-action="settingsPrimaryAction" :default-action="settingsDefaultAction" @primary="saveSettingsChanges" @default="closeSettings">
			        <div class="settings-option">
			            <cdx-checkbox v-model="tempSettings.alwaysCollapsed">
			                {{ commentSectionConfig.settingsCollapseLabel }}
			                <template #description>{{ commentSectionConfig.settingsCollapseDescription }}</template>
			            </cdx-checkbox>
			        </div>
			        <div class="settings-option">
			            <cdx-checkbox v-model="tempSettings.noRedirect">
			                {{ commentSectionConfig.settingsNoRedirectLabel }}
			                <template #description>{{ commentSectionConfig.settingsNoRedirectDescription }}</template>
			            </cdx-checkbox>
			        </div>
			        <div class="settings-option">
			            <cdx-checkbox v-model="tempSettings.hideRecentComments">
			                {{ commentSectionConfig.settingsHideCommentsLabel }}
			                <template #description>{{ commentSectionConfig.settingsHideCommentsDescription }}</template>
			            </cdx-checkbox>
			        </div>
			
			        <div class="settings-option">
					    <cdx-label> {{ commentSectionConfig.settingsCustomIconLabel }}
					        <template #description>
					            <div class="avatar-setting-container">
					                <img :src="commentSectionConfig.icons?.avatarPre" alt="Avatar" class="avatar-preview-image skin-invert" />
					                <div class="avatar-instructions">
					                    <p>{{commentSectionConfig.customAvatarInstruction }}</p>
					                    <cdx-button action="progressive" weight="quiet" @click="openAvatarTemplate" style="padding-left:0;">
					                        {{ commentSectionConfig.customAvatarButtonLabel }}
					                    </cdx-button>
					                </div>
					            </div>
					        </template>
					    </cdx-label>
					</div>
			        <template #footer-text>{{ commentSectionConfig.settingsFooterDescription }}</template>
			    </cdx-dialog>
			    
			    <!-- "Write a comment" button -->
		        <div v-if="!showCommentBox" class="write-comment-button-container">
		            <cdx-button action="progressive" @click="showWriteCommentBox">
		                <img :src="commentSectionConfig.icons?.addComment" alt="Write" class="comment-button-icon skin-invert" />
		                {{ commentSectionConfig.writeCommentButtonLabel }}
		            </cdx-button>
		        </div>
		        <div v-if="showCommentBox">
		            <!-- Comment section Guidlinews notifications -->
			        <cdx-message 
				        v-if="showGuidelinesNotice" 
				        :dismiss-button-label="commentSectionConfig.guidelinesCloseLabel"
				        @dismiss="dismissGuidelines"
				        class="guidelines-notice">
				        {{ commentSectionConfig.guidelinesMessage }}
				        <a :href="commentSectionConfig.guidelinesUrl" target="_blank">{{ commentSectionConfig.guidelinesLinkText }}</a>
				    </cdx-message>
				    
			        <cdx-text-area 
				        v-model="commentText" 
				        :placeholder="commentSectionConfig.commentPlaceholder" 
				        :rows="commentBoxExpanded ? 4 : defaultCollapsedRows" 
				        @focus="expandCommentBox"
				    />
				    <div class="cdx-field__help-text" style="margin: 0.5em 0;">{{ commentSectionConfig.autoSignMessage }}</div>
				
				    <div class="comment-actions">
				        <cdx-button action="progressive" @click="submitComment" :disabled="isSubmitting">{{ isSubmitting ? commentSectionConfig.submittingButtonLabel : commentSectionConfig.submitButtonLabel }}</cdx-button>
				        <cdx-button @click="viewAllComments">{{ commentSectionConfig.viewAllButtonLabel }}</cdx-button>
				        <cdx-button action="destructive" weight="quiet" @click="cancelComment">{{ commentSectionConfig.clearButtonLabel }}</cdx-button>
				    </div>
			    </div>
			    <div class="recent-comments" v-if="!settings.hideRecentComments">
			        <div class="recent-comments-header" @click="toggleRecentComments">
		                <h3 class="cdx-heading">{{ commentSectionConfig.recentCommentsHeader }}</h3>
		                <div class="collapse-indicator">
							<img :src="showRecentComments ? commentSectionConfig.icons?.upArrow : commentSectionConfig.icons?.downArrow" 
							     alt="Toggle" 
							     class="toggle-arrow skin-invert" />
					    </div>
		            </div>
			        <div v-if="showRecentComments">
			            <cdx-progress-bar v-if="loadingStatus === 'loading'" aria-label="Loading comments" indeterminate />
			            <div v-else-if="loadingStatus === 'loaded' && recentComments.length === 0" class="no-comments">
			                {{ commentSectionConfig.noCommentsMessage }}
			            </div>
			            <div v-else-if="loadingStatus === 'loaded' && recentComments.length > 0">
			                <div style="margin: 1.5em 0;">
			                    <cdx-progress-bar v-if="loadingMoreComments" aria-label="Loading comments" indeterminate />
			                </div>
			                <div v-for="(comment, index) in recentComments" :key="comment.id" class="comment-card">
			                    <div class="comment-header">
			                        <div class="user-info">
			                            <div class="avatar">
			                                <img :src="comment.avatar" alt="User avatar" v-if="!comment.isLoading" />
										    <img src="https://upload.wikimedia.org/wikipedia/commons/a/ac/Default_pfp.jpg" alt="Loading..." v-else />
			                            </div>
			                            <span class="username">{{ comment.author }}</span>
			                        </div>
			                        <span class="timestamp">{{ comment.date }}</span>
			                    </div>
			                    <div class="comment-content" v-html="comment.parsedText"></div>
			                    <div class="comment-footer">
			                        <div class="comment-actions-group">
			                            <div class="replies-count" v-if="comment.replyCount > 0">
			                                <img class="reply-icon skin-invert" :src="commentSectionConfig.icons?.reply" alt="Replies">
			                                <span>{{ toBengaliDigits(comment.replyCount) }} {{ comment.replyCount === 1 ? 'টি উত্তর' : 'টি উত্তর' }}</span>
			                            </div>
			                            <div v-if="isLoggedIn" class="like-button" :class="{ 'active': comment.isLiked }" @click="toggleLike(comment)" :title="comment.isLiked ? commentSectionConfig.unlikeButtonTitle : commentSectionConfig.likeButtonTitle">
			                                <img :src="comment.isLiked ? commentSectionConfig.icons?.likeActive : commentSectionConfig.icons?.like" alt="Like" class="skin-invert">
			                                <span class="like-count" v-show="comment.likeCount > 0">{{ commentSectionConfig.likeCount.replace('%s', toBengaliDigits(comment.likeCount)) }}</span>
			                            </div>
			                        </div>
			                        <a href="#" class="view-discussion" @click.prevent="joinDiscussion(comment)">{{ commentSectionConfig.joinDiscussionButtonLabel }}</a>
			                    </div>
			                </div>
			                <div class="comments-pagination" v-if="totalComments > commentsPerPage">
			                    <div class="pagination-container">
			                        <cdx-button class="pagination-nav-button" @click="navigateToPage('previous')" :disabled="currentPage === 0 || loadingMoreComments" weight="quiet">
			                            <span class="pagination-arrow">‹</span> {{ commentSectionConfig.previousButtonLabel }}
			                        </cdx-button>
			                        <div class="pagination-page-indicator">{{ commentSectionConfig.pageIndicatorLabel.replace('%page%', toBengaliDigits(currentPage + 1)).replace('%total%', toBengaliDigits(Math.ceil(totalComments / commentsPerPage))) }}</div>
			                        <cdx-button class="pagination-nav-button" @click="navigateToPage('next')" :disabled="(currentPage + 1) * commentsPerPage >= totalComments || loadingMoreComments" weight="quiet">
			                            {{ commentSectionConfig.nextButtonLabel }} <span class="pagination-arrow">›</span>
			                        </cdx-button>
			                    </div>
			                </div>
			            </div>
			        </div>
			    </div>
			</div>
            `,
            computed: {
                isLoggedIn() {
                    return !!mw.config.get('wgUserName');
                },
                settingsPrimaryAction() {
                    return {
                        label: this.commentSectionConfig.settingsSaveLabel,
                        actionType: 'progressive'
                    };
                },
                settingsDefaultAction() {
                    return {
                        label: this.commentSectionConfig.settingsCloseLabel
                    };
                },
                templateUrl() {
			        const templateName = this.commentSectionConfig.customAvatarTemplate;
			        return mw.util.getUrl(templateName);
			    }
            },
            
            methods: {
                initializeComments() {
				    if (!this.commentsInitialized && !this.isInitialLoading) {
				        this.loadingStatus = 'loading';
				        this.isInitialLoading = true;
				        
				        // Use requestIdleCallback for non-critical initialization
				        (window.requestIdleCallback || window.setTimeout)(() => {
				            this.fetchRecentComments()
				                .catch(error => {
				                    console.error('Failed to initialize comments:', error);
				                    this.loadingStatus = 'error';
				                })
				                .finally(() => {
				                    this.isInitialLoading = false;
				                    this.recentCommentsLoaded = true;
				                });
				        }, { timeout: 1000 });
				        
				        this.commentsInitialized = true;
				    }
				},
                showWriteCommentBox() {
				    this.showCommentBox = true;
				    this.showGuidelinesNotice = true;
				    
				    requestAnimationFrame(() => {
				        if (!this.commentBoxInitialized) {
				            this.commentBoxInitialized = true;
				            
				            // Initialize comments only if needed and not already done
				            if (!this.commentsInitialized && !this.settings.hideRecentComments && this.showRecentComments) {
				                this.initializeComments();
				            }
				        }
				    });
				},
				dismissGuidelines() {
			        this.showGuidelinesNotice = false;
			    },
                openSettings() {
                    this.tempSettings = { ...this.settings };
                    this.settingsOpen = true;
                },
                closeSettings() {
                    this.settingsOpen = false;
                },
                saveSettingsChanges() {
                    this.settings = { ...this.tempSettings };
                    saveSettings(this.settings);
                    
                    this.showRecentComments = !this.settings.alwaysCollapsed;
                    this.settingsOpen = false;
                    
                    if (this.showRecentComments && !this.commentsInitialized && !this.settings.hideRecentComments) {
                        this.initializeComments();
                    }
                },
                openAvatarTemplate() {
			        window.open(this.templateUrl, '_blank');
			    },
                expandCommentBox() {
			        this.commentBoxExpanded = true;
			    },
                cancelComment() {
		            this.commentText = '';
		            this.commentBoxExpanded = false;
		            this.showCommentBox = false;
		        },
                toggleRecentComments() {
				    this.showRecentComments = !this.showRecentComments;
				    
				    if (this.showRecentComments && !this.recentCommentsLoaded) {
				        // Use requestAnimationFrame to ensure visibility update before loading
				        requestAnimationFrame(() => {
				            this.initializeComments();
				        });
				    }
				},
                toBengaliDigits(number) {
                    return toBengaliDigits(number);
                },
                joinDiscussion(comment) {
                    // Use the originalHeader to create the correct anchor
                    const sectionAnchor = encodeURIComponent(comment.originalHeader);
                    const talkPageUrl = mw.util.getUrl(this.talkPageTitle) + '#' + sectionAnchor;
                    window.open(talkPageUrl, '_blank');
                },
                
                async parseWikitext(wikitext) {
				    const cacheKey = wikitext.trim();
				    
				    // Check memory cache first
				    if (parsedCache.has(cacheKey)) {
				        return parsedCache.get(cacheKey);
				    }
				    
				    const createSafeKey = (text) => {
				        let hash = 0;
				        for (let i = 0; i < text.length; i++) {
				            const char = text.charCodeAt(i);
				            hash = ((hash << 5) - hash) + char;
				            hash = hash & hash;
				        }
				        return 'parsed_' + Math.abs(hash).toString(36);
				    };
				    
				    // Check sessionStorage cache with safe key
				    const storageKey = createSafeKey(cacheKey.substring(0, 50));
				    const cachedParsed = sessionStorage.getItem(storageKey);
				    if (cachedParsed) {
				        parsedCache.set(cacheKey, cachedParsed);
				        return cachedParsed;
				    }
				
				    try {
				        const result = await wikiNewsComments.api.post({
				            action: 'parse',
				            text: wikitext,
				            contentmodel: 'wikitext',
				            format: 'json'
				        });
				        
				        const parsed = result.parse.text['*'];
				        
				        // Cache the result
				        parsedCache.set(cacheKey, parsed);
				        try {
				            sessionStorage.setItem(storageKey, parsed);
				        } catch (e) {
				            // Handle storage quota exceeded
				            console.warn('SessionStorage quota exceeded, couldn\'t cache parsed text');
				        }
				        
				        return parsed;
				    } catch (error) {
				        console.error('Error parsing wikitext:', error);
				        return wikitext;
				    }
				},
                getRandomAvatar(commentId) {
			        return getRandomAvatar(commentId);
			    },
                async fetchRecentComments() {
				    try {
				        this.isInitialLoading = true;
				        this.loadingStatus = 'loading';
				
				        const response = await wikiNewsComments.api.get({
				            action: 'query',
				            prop: 'revisions',
				            titles: this.talkPageTitle,
				            rvprop: 'content',
				            rvlimit: 1,
				            rvslots: 'main',
				            formatversion: '2'
				        });
				
				        if (response.query.pages[0].missing || !response.query.pages[0].revisions) {
				            this.recentComments = [];
				            this.totalComments = 0;
				            this.loadingStatus = 'loaded';
				            return;
				        }
				
				        const content = response.query.pages[0].revisions[0].slots.main.content;
				        this.pageContent = content;
				
				        const sectionMatch = content.match(/== মন্তব্য বিভাগ ==([\s\S]*?)(?=\n==[^=]|$)/);
				        if (!sectionMatch) {
				            this.recentComments = [];
				            this.totalComments = 0;
				            this.loadingStatus = 'loaded';
				            return;
				        }
				
				        // Store all matches, reversed for newest-first order
				        this.commentMatches = [...sectionMatch[1].matchAll(/=== (.*? এর দ্বারা মন্তব্য(?:\s+\([^)]+\))?) ===\n([\s\S]*?)(?=\n===|$)/g)].reverse();
				        this.totalComments = this.commentMatches.length;
				
				        // Load only the first page - this avoids processing all comments at once
				        this.currentPage = 0;
				        this.commentsPerPage = 3;
				        await this.loadCommentsForCurrentPage();
				
				    } catch (error) {
				        console.error('Error loading comments:', error);
				        this.recentComments = [];
				        this.totalComments = 0;
				        this.loadingStatus = 'error';
				    } finally {
				        this.isInitialLoading = false;
				    }
				},
                
                async getCommentAvatar(comment) {
				    const username = comment.author;
				    const commentId = comment.id;
				
				    if (this.avatarCache.has(username)) {
				        return this.avatarCache.get(username);
				    }
				
				    const avatarUrl = await getAvatar(username, commentId);
				    this.avatarCache.set(username, avatarUrl);
				    return avatarUrl;
				},
								
				async loadCommentsForCurrentPage() {
				    this.loadingMoreComments = true;
				    const start = this.currentPage * this.commentsPerPage;
				    const end = Math.min(start + this.commentsPerPage, this.commentMatches.length);
				    const currentPageMatches = this.commentMatches.slice(start, end);
				
				    // Clear previous comments
				    this.recentComments = [];
				
				    try {
				        // First pass: Create minimal comment objects for immediate rendering
				        const commentPromises = currentPageMatches.map(async (match, i) => {
				            const [_, authorWithCounter, text] = match;
				            const id = start + i;
				            const { username } = parseCommentHeader(authorWithCounter);
				
				            // Extract basic data that doesn't require API calls
				            const { likeCount, reactors } = extractReactionData(text);
				            const currentUsername = mw.config.get('wgUserName');
				            const isLiked = currentUsername ? reactors.includes(currentUsername) : false;
				            const cleanedText = cleanupCommentText(text);
				            const mainCommentText = getMainComment(cleanedText);
				            const date = extractDateFromText(mainCommentText);
				            const cleanCommentText = cleanTimestamp(mainCommentText);
				
				            const comment = {
				                id,
				                author: username,
				                originalHeader: match[1],
				                text,
				                parsedText: cleanCommentText,
				                date,
				                avatar: 'https://upload.wikimedia.org/wikipedia/commons/a/ac/Default_pfp.jpg',
				                replyCount: countReplies(text),
				                likeCount,
				                isLiked,
				                isLoading: true
				            };
				
				            this.recentComments.push(comment);
				            return comment;
				        });
				
				        // Force UI update after basic information is available
				        this.$forceUpdate();
				
				        // Second pass: Process heavy operations in parallel, but not all at once
				        // Process comments in batches to avoid overwhelming the browser
				        const batchSize = 1; // Process one comment at a time
				        const comments = await Promise.all(commentPromises);
				        
				        for (let i = 0; i < comments.length; i += batchSize) {
				            const batch = comments.slice(i, i + batchSize);
				            
				            // Process each batch in parallel
				            await Promise.all(batch.map(async (comment) => {
				                try {
				                    // Split these operations to allow independent completion
				                    const parsedTextPromise = this.parseWikitext(comment.parsedText);
				                    const avatarPromise = this.getCommentAvatar(comment);
				                    
				                    // Wait for both operations to complete
				                    const [parsedText, avatar] = await Promise.all([parsedTextPromise, avatarPromise]);
				                    
				                    // Update comment with rich content
				                    comment.parsedText = parsedText;
				                    comment.avatar = avatar;
				                    comment.isLoading = false;
				                    
				                    // Update UI incrementally as each comment is processed
				                    this.$forceUpdate();
				                } catch (err) {
				                    console.error(`Error processing comment ${comment.id}:`, err);
				                    comment.isLoading = false;
				                }
				            }));
				        }
				        
				        this.loadingStatus = 'loaded';
				    } catch (error) {
				        console.error('Error processing comments:', error);
				        this.loadingStatus = 'error';
				    } finally {
				        this.loadingMoreComments = false;
				    }
				},
                
                navigateToPage(direction) {
				    const oldPage = this.currentPage;
				    
				    if (direction === 'previous' && this.currentPage > 0) {
				        this.currentPage--;
				    } else if (direction === 'next' && (this.currentPage + 1) * this.commentsPerPage < this.totalComments) {
				        this.currentPage++;
				    } else {
				        return;
				    }
				    
				    // Only load comments if the page actually changed
				    if (oldPage !== this.currentPage) {
				        this.loadingMoreComments = true;
				        this.loadingStatus = 'loading';
				        
				        // Clear comments immediately to show loading state
				        this.recentComments = [];
				        this.$forceUpdate();
				        
				        // Use requestAnimationFrame to ensure UI updates before heavy operations
				        requestAnimationFrame(async () => {
				            await this.loadCommentsForCurrentPage();
				            this.scrollToCommentsTop();
				        });
				    }
				},
                
                scrollToCommentsTop() {
                    const commentsHeader = document.querySelector('.recent-comments-header');
                    if (commentsHeader) {
                        commentsHeader.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                },
				
                async submitComment() {
                	// Check if user is logged in
				    if (!mw.config.get('wgUserName')) {
				        // Redirect to login page
				        window.location.href = mw.util.getUrl('Special:UserLogin', {
				            returnto: mw.config.get('wgPageName')
				        });
				        return;
				    }
				    if (!this.commentText.trim()) {
				        mw.notify(this.commentSectionConfig.emptyCommentError, { type: 'error' });
				        return;
				    }
				
				    this.isSubmitting = true;
				
				    try {
				        const response = await wikiNewsComments.api.get({
				            action: 'query',
				            prop: 'revisions',
				            titles: this.talkPageTitle,
				            rvprop: 'content',
				            rvlimit: 1
				        });
				
				        const pages = response.query.pages;
				        const pageId = Object.keys(pages)[0];
				        const currentContent = pages[pageId].revisions ? pages[pageId].revisions[0]['*'] : '';
				        const pageExists = !pages[pageId].missing;
				
				        const username = mw.config.get('wgUserName');
				        
				        // Get the appropriate counter for this user's comments
				        const counter = getNextCommentCounter(username, currentContent);
				        
				        // Create the full comment header with counter if needed
				        const commentHeader = `${username} এর দ্বারা মন্তব্য${counter}`;
				        
				        // Create the formatted comment
						let newComment = `\n=== ${commentHeader} ===\n${cleanupCommentText(this.commentText.trim())} ` + `<span id="user-sign">--${"~".repeat(4)}</span>\n`;
						
				        let updatedContent;
				        if (!pageExists || !currentContent.includes(`== ${this.commentSectionConfig.commentSectionTitle} ==`)) {
				            updatedContent = (currentContent ? currentContent + '\n\n' : '') +
				                `== ${this.commentSectionConfig.commentSectionTitle} ==\n${this.commentSectionConfig.commentTemplate}\n` + 
				                newComment;
				        } else {
				            const sections = currentContent.split(/(?=^== .*? ==\n)/m);
				            const commentSectionIndex = sections.findIndex(section => 
				                section.startsWith(`== ${this.commentSectionConfig.commentSectionTitle} ==`));
				            
				            if (commentSectionIndex !== -1) {
				                sections[commentSectionIndex] = sections[commentSectionIndex].replace(/\n*$/, '\n');
				                sections[commentSectionIndex] += newComment;
				                updatedContent = sections.join('');
				            } else {
				                updatedContent = currentContent + 
				                    `\n\n== ${this.commentSectionConfig.commentSectionTitle} ==\n${this.commentSectionConfig.commentTemplate}\n` + 
				                    newComment;
				            }
				        }
				
				        await wikiNewsComments.api.postWithToken('csrf', {
				            action: 'edit',
				            title: this.talkPageTitle,
				            text: updatedContent,
				            summary: this.commentSectionConfig.editSummary,
				            createonly: false
				        });
				
				        mw.notify(this.commentSectionConfig.successMessage, { type: 'success' });
				        this.commentText = '';
				        
				        // Create talkPageUrl within the scope where it's used
				        const talkPageUrl = mw.util.getUrl(this.talkPageTitle) + '#মন্তব্য_বিভাগ';
				        
				        if (!this.settings.noRedirect) {
				            window.open(talkPageUrl, '_blank');
				        }
				        
				        // Refresh the comments list immediately after successful submission
				        await this.fetchRecentComments();
				
				    } catch (error) {
				        mw.notify(this.commentSectionConfig.errorPrefix + error, { type: 'error' });
				    } finally {
				        this.isSubmitting = false;
				    }
				},
                viewAllComments() {
                    const talkPageUrl = mw.util.getUrl(this.talkPageTitle) + '#মন্তব্য_বিভাগ';
                    window.open(talkPageUrl, '_blank');
                },
                extractReactionData(text) {
                	return extractReactionData(text);
                },
                createReactionTemplate (likeCount, reactors) {
                	return createReactionTemplate (likeCount, reactors);
                },
			    async toggleLike(comment) {
				    const username = mw.config.get('wgUserName');
				    if (!username) {
				        // Redirect to login page
				        window.location.href = mw.util.getUrl('Special:UserLogin', {
				            returnto: mw.config.get('wgPageName')
				        });
				        return;
				    }
				    
				    // Immediately update UI for responsiveness
				    const wasLiked = comment.isLiked;
				    comment.isLiked = !wasLiked;
				    comment.likeCount = wasLiked ? Math.max(0, comment.likeCount - 1) : comment.likeCount + 1;
				    
				    mw.notify(this.commentSectionConfig.likeUpdateMessage, { type: 'info' });
				    
				    try {
				        // Get current talk page content
				        const response = await wikiNewsComments.api.get({
				            action: 'query',
				            prop: 'revisions',
				            titles: this.talkPageTitle,
				            rvprop: 'content',
				            rvlimit: 1,
				            formatversion: '2'
				        });
				        
				        if (!response.query.pages[0].revisions) {
				            throw new Error('Talk page does not exist');
				        }
				        
				        const content = response.query.pages[0].revisions[0].content || 
				                        response.query.pages[0].revisions[0].slots?.main?.content;
				        
				        // Pre-compile regex patterns
				        const escapedHeader = comment.originalHeader.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
				        const sectionRegex = new RegExp(`=== ${escapedHeader} ===(\\n[\\s\\S]*?)(?=\\n===|$)`, 'm');
				        let sectionMatch = content.match(sectionRegex);
				        let sectionText, updatedContent;
				        
				        // If not found with that pattern, try the fallback pattern
				        if (!sectionMatch) {
				            const { username: commentUsername } = parseCommentHeader(comment.originalHeader);
				            const escapedUsername = commentUsername.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
				            const fallbackRegex = new RegExp(`=== ${escapedUsername} এর দ্বারা মন্তব্য(?:\\s+\\([^)]+\\))? ===(\\n[\\s\\S]*?)(?=\\n===|$)`, 'm');
				            const fallbackMatch = content.match(fallbackRegex);
				            
				            if (!fallbackMatch) {
				                throw new Error('Comment section not found');
				            }
				            
				            sectionText = fallbackMatch[1];
				            
				            // Update content with fallback pattern
				            const { reactors, hasReactionTemplate, templateText } = this.extractReactionData(sectionText);
				            const userIndex = reactors.indexOf(username);
				            const isLiked = userIndex !== -1;
				            
				            // Update reactors array
				            let newReactors = isLiked ? 
				                [...reactors.slice(0, userIndex), ...reactors.slice(userIndex + 1)] : 
				                [...reactors, username];
				            
				            // Create updated template
				            const newTemplate = this.createReactionTemplate(newReactors.length, newReactors);
				            
				            // Update section text
				            let updatedSectionText = hasReactionTemplate ? 
				                sectionText.replace(templateText, newTemplate) : 
				                `\n${newTemplate}${sectionText}`;
				                
				            updatedContent = content.replace(fallbackRegex, `=== ${comment.originalHeader} ===${updatedSectionText}`);
				            
				            // Update comment with correct values
				            comment.isLiked = !isLiked;
				            comment.likeCount = newReactors.length;
				        } else {
				            sectionText = sectionMatch[1];
				            
				            // Extract and update reaction data
				            const { reactors, hasReactionTemplate, templateText } = this.extractReactionData(sectionText);
				            const userIndex = reactors.indexOf(username);
				            const isLiked = userIndex !== -1;
				            
				            // Update reactors array
				            let newReactors = isLiked ? 
				                [...reactors.slice(0, userIndex), ...reactors.slice(userIndex + 1)] : 
				                [...reactors, username];
				            
				            // Create updated template
				            const newTemplate = this.createReactionTemplate(newReactors.length, newReactors);
				            
				            // Update section text
				            let updatedSectionText = hasReactionTemplate ? 
				                sectionText.replace(templateText, newTemplate) : 
				                `\n${newTemplate}${sectionText}`;
				                
				            updatedContent = content.replace(sectionRegex, `=== ${comment.originalHeader} ===${updatedSectionText}`);
				            
				            // Update comment with correct values
				            comment.isLiked = !isLiked;
				            comment.likeCount = newReactors.length;
				        }
				        
				        // Save changes
				        await wikiNewsComments.api.postWithToken('csrf', {
				            action: 'edit',
				            title: this.talkPageTitle,
				            text: updatedContent,
				            summary: comment.isLiked ? 'একটি মন্তব্যকে লাইক করা হয়েছে' : 'একটি মন্তব্য থেকে লাইক সরিয়ে নেওয়া হয়েছে',
				            createonly: false
				        });
				        
				        // Show success message
				        mw.notify(
				            comment.isLiked ? this.commentSectionConfig.likeSuccessMessage : this.commentSectionConfig.unlikeSuccessMessage,
				            { type: 'success' }
				        );
				        
				    } catch (error) {
				        // Revert the UI changes if the server operation failed
				        comment.isLiked = wasLiked;
				        comment.likeCount = wasLiked ? comment.likeCount + 1 : Math.max(0, comment.likeCount - 1);
				        
				        mw.notify(this.commentSectionConfig.likeErrorMessage + (error.message || ''), { type: 'error' });
				    }
				}
            },
            mounted() {
			    if (!this.settings.hideRecentComments && this.showRecentComments) {
			        this.fetchRecentComments();
			    }
			}
        })
        .component('cdx-button', Codex.CdxButton)
        .component('cdx-text-area', Codex.CdxTextArea)
        .component('cdx-dialog', Codex.CdxDialog)
        .component('cdx-checkbox', Codex.CdxCheckbox)
        .component('cdx-progress-bar', Codex.CdxProgressBar)
        .component('cdx-label', Codex.CdxLabel)
        .component('cdx-message', Codex.CdxMessage)
        .mount(existingCommentSection);
    });
});

mw.loader.addStyleTag(`

.wikinews-comments-container {
    margin: 1.6em 0;
    padding: 1.25em;
    border: 1px solid #c8ccd1;
    background-color: #ffffff;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    position: relative;
    transition: all 0.2s ease;
}

.vector-feature-main-menu-pinned-enabled .wikinews-comments-container {
    max-width: 960px;
}

.cdx-heading {
    margin-bottom: .75em; 
}

.wikinews-comments-container h2 {
    border-bottom: none;
}

.cdx-field__help-text {
    font-size: .875em;
}

.write-comment-button-container {
    margin: 1em 0;
    display: flex;
    justify-content: center;
    align-items: center;
}

.comment-button-icon {
    vertical-align: middle;
    width:16px;
    height:16px;
    margin-right:8px;
}

/* ================== Settings ================== */

.settings-icon {
    position: absolute;
    top: 2em;
    right: 1em; 
    width: 20px;
    height: 20px;
    cursor: pointer;
    transition: transform 0.3s ease;
}

.settings-icon:hover {
    transform: scale(1.1);
}

.settings-option {
    margin: 15px 0;
}

.avatar-setting-container { 
    display: flex;
    align-items: center;
    margin-top: 0.5em;
}
.avatar-preview-image {
    width: 32px;
    height: 32px;
    margin-right: 1em;
}
.avatar-instructions { 
    flex: 1; 
}
.avatar-instructions p { 
    margin-bottom: 0.25em; 
}


/* ================== Comment Actions ================== */

.comment-actions {
    margin-top: 0.875em;
    display: flex;
    gap: 0.875em;
    justify-content: flex-end;
    flex-wrap: wrap;
}

/* ================== Recent Comments Section ================== */

.recent-comments {
    margin-top: 2em;
    border-top: 1px solid #eaecf0;
    padding-top: 1.5em;
    transition: all 0.3s ease;
}

.recent-comments-header {
    display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 12px;
	margin-bottom: 12px;
	color: #202122;
	cursor: pointer;
	background-color: #f1f3f5;
	border-radius: 2px;
	transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}

.recent-comments-header h3 {
    margin: 0;
    padding: 0;
    color: #000;
}

.recent-comments-header:hover {
	background-color: #e9ecef;
}

.toggle-arrow {
    width: 25px; 
    height: 25px;
	transition: transform 0.3s ease;
}

.no-comments {
    color: #777;
    text-align: center;
    padding: 1em;
}

.guidelines-notice {
    margin-bottom: 1em;
}

/* ================== Comment Cards ================== */

.comment-card {
    background-color: white;
    border: 1px solid #d5d5d5;
    border-radius: 4px;
    padding: 12px;
    margin-bottom: 12px;
    border-left: 3px solid #36c;
}

.comment-card:hover {
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
}

.comment-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
    align-items: center;
}

.user-info {
    display: flex;
    align-items: center;
}

.avatar {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    overflow: hidden;
    margin-right: 10px;
    border: 1px solid #eaecf0;
    background-color: #f8f9fa;
}

.avatar img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.3s ease;
}

.username {
    font-weight: 600;
    color: #0645ad;
}

.timestamp {
    color: #777;
    font-size: 13px;
}

.comment-content {
    margin-bottom: 10px;
    line-height: 1.5;
}

.comment-footer {
    display: flex;
    justify-content: space-between;
    font-size: 0.85em;
    color: #54595d;
    align-items: center;
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid #eaecf0;
}

/* ================== Comment Interactions ================== */

.replies-count {
    display: flex;
    align-items: center;
    padding: 4px 8px;
    border-radius: 12px;
    background-color: #f8f9fa;
    transition: background-color 0.2s;
}

.replies-count:hover {
    background-color: #eaecf0;
}

.reply-icon {
    margin-right: 6px;
    height: 14px;
    width: 14px;
    opacity: 0.7;
}

.view-discussion {
    color: #0645ad;
    text-decoration: none;
    margin-left: auto;
    padding: 4px 8px;
    border-radius: 2px;
    transition: all 0.2s ease;
}

.view-discussion:hover {
    text-decoration: underline;
    background-color: rgba(51, 102, 204, 0.1);
}

.comment-actions-group {
    display: flex;
    align-items: center;
    gap: 0.75em;
}

/* ================== Like Button ================== */

.like-button {
    display: flex;
    align-items: center;
    gap: 0.35em;
    cursor: pointer;
    padding: 4px 10px;
    border-radius: 12px;
    transition: all 0.2s;
    background-color: #f8f9fa;
}

.like-button:hover {
    background-color: #eaecf0;
}

.like-button img {
    width: 16px;
    height: 16px;
    transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.like-button:hover img {
    transform: scale(1.2);
}

.like-button.active {
    background-color: rgba(51, 102, 204, 0.1);
}

.like-button.active img {
    filter: invert(45%) sepia(99%) saturate(1464%) hue-rotate(199deg) brightness(98%) contrast(96%);
    transform: scale(1.1);
}

.like-count {
    font-size: 0.9em;
    color: #54595d;
    font-weight: 500;
    transition: all 0.2s;
}

.like-button.active .like-count {
    color: #3366cc;
    font-weight: bold;
}

/* Animation for like action */
@keyframes likeAnimation {
    0% { transform: scale(1); }
    50% { transform: scale(1.5); }
    100% { transform: scale(1); }
}

.like-button.animate img {
    animation: likeAnimation 0.5s ease-in-out;
}

/* ================== Pagination ================== */

.pagination-container {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin: 1.5em 0;
    border-top: 1px solid #eaecf0;
    padding-top: 1em;
}

.pagination-nav-button {
    display: flex;
    align-items: center;
}

.pagination-arrow {
    font-size: 1.2em;
    font-weight: bold;
}

.pagination-page-indicator {
    color: #54595d;
    font-size: 0.9em;
}

/* ================== Dark Mode Styles ================== */

/* Forced night mode */
@media screen {
    html.skin-theme-clientpref-night .wikinews-comments-container {
        background-color: #1a1a1a;
        border: 1px solid #444;
        box-shadow: 0 1px 2px rgba(255, 255, 255, 0.1);
    }
    
    html.skin-theme-clientpref-night .recent-comments-header {
        color: #ccc;
        background-color: #2a2a2a;
    }
    
    html.skin-theme-clientpref-night .recent-comments-header:hover {
	    background-color: #3a3a3a;
	}

    html.skin-theme-clientpref-night .recent-comments-header h3 {
        color: #fff;
    }
    
    html.skin-theme-clientpref-night .comment-card {
        background-color: #222;
        border-color: #444;
        border-left: 3px solid #66c;
    }
    
    html.skin-theme-clientpref-night .username {
        color: #6699ff;
    }
    
    html.skin-theme-clientpref-night .timestamp,
    html.skin-theme-clientpref-night .replies-count {
        color: #999;
    }
    
    html.skin-theme-clientpref-night .view-discussion {
        color: #6699ff;
    }
    
    html.skin-theme-clientpref-night .comment-footer {
        border-top-color: #444;
    }
    
    html.skin-theme-clientpref-night .no-comments {
        color: #999;
    }
    
    html.skin-theme-clientpref-night .like-button {
	    background-color: #2c2f33;
	    color: #ffffff;
	    transition: all 0.2s;
	}

    html.skin-theme-clientpref-night .like-button:hover {
        background-color: rgba(255, 255, 255, 0.1);
    }
    
    html.skin-theme-clientpref-night .like-count {
        color: #aaa;
    }
    
    html.skin-theme-clientpref-night .like-button.active .like-count {
        color: #6699ff;
    }
    
    html.skin-theme-clientpref-night .like-button.active img {
        filter: invert(45%) sepia(99%) saturate(1464%) hue-rotate(199deg) brightness(98%) contrast(96%);
    }
    
    html.skin-theme-clientpref-night .replies-count {
	    background-color: #2c2f33;
	    transition: background-color 0.2s;
	    color: #ffffff;
	}
	
	html.skin-theme-clientpref-night .replies-count:hover {
	    background-color: #23272a;
	}
    
    html.skin-theme-clientpref-night .pagination-container {
        border-top-color: #444;
    }
    
    html.skin-theme-clientpref-night .pagination-page-indicator {
        color: #aaa;
    }
    
    html.skin-theme-clientpref-night .pagination-nav-button {
        color: #6699ff;
    }
}

/* Automatic dark mode */
@media screen and (prefers-color-scheme: dark) {
    html.skin-theme-clientpref-os .wikinews-comments-container {
        background-color: #1a1a1a;
        border: 1px solid #444;
        box-shadow: 0 1px 2px rgba(255, 255, 255, 0.1);
    }
    
    html.skin-theme-clientpref-os .recent-comments-header {
        color: #ccc;
        background-color: #2a2a2a;
    }
    
    html.skin-theme-clientpref-os .recent-comments-header:hover {
	    background-color: #3a3a3a;
	}

    html.skin-theme-clientpref-os .recent-comments-header h3 {
        color: #fff;
    }
    
    html.skin-theme-clientpref-os .comment-card {
        background-color: #222;
        border-color: #444;
        border-left: 3px solid #66c;
    }
    
    html.skin-theme-clientpref-os .username {
        color: #6699ff;
    }
    
    html.skin-theme-clientpref-os .timestamp,
    html.skin-theme-clientpref-os .replies-count {
        color: #999;
    }
    
    html.skin-theme-clientpref-os .view-discussion {
        color: #6699ff;
    }
    
    html.skin-theme-clientpref-os .comment-footer {
        border-top-color: #444;
    }
    
    html.skin-theme-clientpref-os .no-comments {
        color: #999;
    }
    
    html.skin-theme-clientpref-os .like-button {
	    background-color: #2c2f33;
	    color: #ffffff;
	    transition: all 0.2s;
	}

    html.skin-theme-clientpref-os .like-button:hover {
        background-color: rgba(255, 255, 255, 0.1);
    }
    
    html.skin-theme-clientpref-os .like-count {
        color: #aaa;
    }
    
    html.skin-theme-clientpref-os .like-button.active .like-count {
        color: #6699ff;
    }
    
    html.skin-theme-clientpref-os .like-button.active img {
        filter: invert(45%) sepia(99%) saturate(1464%) hue-rotate(199deg) brightness(98%) contrast(96%);
    }
    
    html.skin-theme-clientpref-os .replies-count {
	    background-color: #2c2f33;
	    transition: background-color 0.2s;
	    color: #ffffff;
	}
	
	html.skin-theme-clientpref-os .replies-count:hover {
	    background-color: #23272a;
	}
    
    html.skin-theme-clientpref-os .pagination-container {
        border-top-color: #444;
    }
    
    html.skin-theme-clientpref-os .pagination-page-indicator {
        color: #aaa;
    }
    
    html.skin-theme-clientpref-os .pagination-nav-button {
        color: #6699ff;
    }
}

/* ================== Responsive Adjustments ================== */

@media (max-width: 768px) {
    .wikinews-comments-container {
        padding: 1em;
        margin: 1em 0;
    }

    .comment-actions {
        gap: 0.5em;
    }

    .recent-comments-header {
        flex-direction: row;
        flex-wrap: wrap;
        gap: 0.5em;
    }
    
    .comment-header {
        align-items: flex-start;
        gap: 0.3em;
        flex-wrap: wrap;
    }
    
    .timestamp {
        font-size: 0.8em;
        margin-top: 0.2em;
    }
    
    .comment-card {
        padding: 12px;
        margin-bottom: 12px;
    }
    
    .comment-footer {
        flex-wrap: wrap;
        gap: 0.5em;
    }
    
}

.comment-card:focus-within {
    border-color: #36c;
    outline: 2px solid #36c;
    outline-offset: 1px;
}
`);

// </nowiki>
